Facts
=====

Datomic is designed to be directly programmable using data that represents Facts
in the real world. Represented as Entities with Attributes and Values, the
primary interface to Datomic is a tuple of Facts (a vector/array data
structures), not strings or DDL or DML. Datomic's concepts thus center around
Facts, how they're created, found, and managed over time.


## Indentity

Datomic provides many ways to model identity to uniquely identify a Fact, or its attributes which we will cover soon.

Datomic auto-generates entity ids and stores them as part of every datom. To
simplify application access, `:db/ident` provides a keyword-based lookup to
entities that can be used by apis querying through entity 'id'.

For ex the following record can be accessed via `:person/name` lookup, instead
of the generated id.

    {:db/id #db/id[:db.part/db]
     :db/ident :person/name}

Identities can also be used to implement enumerated tags.

    {:db/id #db/id[:db.part/db]
     :db/ident :label/type
     :db/doc "Enum, one of :label.type/distributor, :label.type/holding,
        :label.type/production, :label.type/originalProduction,
        :label.type/bootlegProduction, :label.type/reissueProduction, or
        :label.type/publisher."}

`Unique identities` allow attributes to have unique values.

    {:db/id #db/id[:db.part/db]
     :db/ident :person/email
     :db/unique :db.unique/identity}

A unique identity attribute is always indexed by value.

`Lookup Refs' are _Business Keys_ on steroids: a list containing an attribute
and value.

    [:person/email "joe@example.com"]

To refer to existing entities in a transaction, avoiding extra lookup code, use:

    {:db/id [:person/email "rich@example.com"]
     :person/name :rich}

Note that Lookup refs _cannot_ be used in queries.

`Squuids` provide efficient, globally unique identifiers. They are _not_ real
UUIDs, but they come close as semi-sequential uuids. As long you don't generate
thousands of squuids every millisecond, indexes based on squuids will not
fragment: the first part of a squuid is based on the system time.

`ident` is designed to be fast. 

In general, queries against a single database can lookup entity ids via other
kinds of identifiers, but for efficiency should join by entity id.

## Entities, Attributes & Values

A Datomic entity is simply a _Fact_ providing a lazy, associative view of all
the information that can be reached from its id.

Let' revisit our 4-tuple Fact:

    [entity attribute value transaction]

- entity: entity id (typically, an auto-generated id)
- attribute: Clojure keyword representing both the model (namespace :person) 
  and attribute name (firstName)
- value: any value
- transaction: tx id generated by datomic; used internally for time-based 
  queries

Note that entities are not a mapping layer between databases and application
code: they're a direct translation from information stored in the database to
application as raw data structures.

Entity references are bi-directional by default:

    [{:db/id #db/id[:db.part/user -1]
      :person/name "Bob"
      :person/spouse #db/id[:db.part/user -2]}
     {:db/id #db/id[:db.part/user -2]
      :person/name "Alice"
      :person/spouse #db/id[:db.part/user -1]}]

Entity attributes are accessed lazily as you request them. 

They aren't typed.

_Let's revisit_: Fact (datom) is entity-attribute-value-transaction. Therefore,
attribute/value pair and the transaction are associated with the entity, which
is a number. The transaction holds the time. We create a new entity when we
transact an attribute without specifying entity. We change the attribute (add,
"update") when we transact with the entity.

An Entity is referred by a generated id or keyword. Attributes are simply
namespaced-keywords. A value can be scalar (String, Integer, etc.,), or a
reference to another Entity. This reference establishes a relationship between
two entities. Though analogous to the concept of a _foreign-key_, Datomic
reference is just the value of the referenced attribute.

## Facts

The data model in Datomic is based around atomic facts called datoms: a single,
flat, universal relation.

There is no other structural component to Datomic.

A datom is a 4-tuple consisting of:

    [entity attribute value transaction]

Any model in real or manufactured world can be represented in this 4-tuple.

For ex, a Person can be created as:

    [100 :person/firstName "Rich" 1000]

Note that entity and transaction here are arbitrary numbers (can be generated by Datomic).

A blog can be modeled as two facts:

    [200 :blog/title "on datomic" 1000]
    [200 :blog/entry "datomic will change the way you think of databases" 1000]

A registration page can save a web form as a set of facts:

     [100 :user.registration/name "clojure-addict" 1000]
     [200 :user.registration/email "hello@example.com" 1000]
     [300 :user.registration/address "1 mission street san francisco ca 94103" 1000]

And so on.

## Transactions

Datomic transactions are ACID: Atomic, Consistent, Isolated, and Durable.

If you're performing CRUD operations, there is no `U` & `D` in Dataomic, only
Create and Read. Update is considered as 'Retract'ing of an existing attribute.

Transaction requests are data structures. Each operation to the db is
represented as a tuple of four things:

    [op entity-id attribute value]
    ;; op is one of :db/add and :db/retract.

Sample:

    {:db/id entity-id
     attribute value
     attribute value
     ... }

Create - `db:add`

To add data to an existing entity, build a transaction using :db/add implicitly
with the map structure (or explicitly with the list structure). The following
example shows creating data using a transaction:

    (d/transact conn
        [;; A user posting an article
          {:db/id #db/id [:db.part/user -100]
           :user/username "rich.hickey"}
          {:db/id #db/id [:db.part/user -200]
           :category/name "Functional Programming"}
          {:db/id #db/id [:db.part/user -300]
           :article/title "Scala, the bad parts"
           :article/author #db/id [:db.part/user -100]
           :article/category #db/id [:db.part/user -200]
           :article/body "Scala is ..."}])

A Datomic database is as a universal relation of datoms, i.e. 5-tuples of the form:

	[entity attribute value transaction added?]

*Additional Notes*:

- Every tx is yet another datum
- `transact` takes a vector of vectors: [Op, Ent, Attr, Val]; consider it a
  vector of assertions
- `transact` can be sync or async; both return a promise
- Sync transactions have an implicit timeout
- Single value vs multi-valued attribute => db cardinality
- Within a tx, a tempid (-100) denotes the same "new" entity; scope of a 
  tempid is a single tx
- Tx itself is an entity!
- Tuples within a tx is not ordered
- A single tx can and will contain multiple attribute changes
